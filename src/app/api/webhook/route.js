import { NextResponse } from 'next/server';
import { MercadoPagoConfig, Payment } from 'mercadopago';
import crypto from 'crypto';
import { logInfo, logError, logWarn } from '../../../utils/logger';
import { createClient } from '@supabase/supabase-js';
import { updateStockAfterOrder, restoreStockAfterRefund, updateOrderStatus } from '../../../lib/productService';
import { generateReceiptPDF } from '../../../lib/pdfService';
import { sendReceiptEmail, sendRefundEmail, notifyChargebackToAdmins } from '../../../lib/emailService';

// Verificar variables cr√≠ticas al cargar el m√≥dulo
if (!process.env.MERCADOPAGO_WEBHOOK_KEY) {
  console.error('‚ùå CRITICAL: MERCADOPAGO_WEBHOOK_KEY no est√° definida');
}

if (!process.env.MERCADOPAGO_ACCESS_TOKEN) {
  console.error('‚ùå CRITICAL: MERCADOPAGO_ACCESS_TOKEN no est√° definida');
}

console.log('üîß Webhook variables check:', {
  hasWebhookKey: !!process.env.MERCADOPAGO_WEBHOOK_KEY,
  hasAccessToken: !!process.env.MERCADOPAGO_ACCESS_TOKEN,
  environment: process.env.NODE_ENV,
  webhookKeyLength: process.env.MERCADOPAGO_WEBHOOK_KEY?.length
});

// Inicializar Supabase
const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
const supabase = createClient(supabaseUrl, supabaseKey);

// Funci√≥n CORREGIDA para validar firma seg√∫n documentaci√≥n oficial de MercadoPago v2.6
function buildSignatureManifest({ ts, id, requestId }) {
  return `id:${id};request-id:${requestId};ts:${ts};`;
}

function verifyWebhookSignature({ signatureHeader, rawBody, secret, id, requestId }) {
  try {
    // Extraer timestamp y signature del header x-signature
    const signatureMatch = signatureHeader.match(/ts=(\d+),v1=([a-f0-9]+)/);
    if (!signatureMatch) {
      logWarn('‚ùå Formato de signature header inv√°lido:', signatureHeader);
      return false;
    }

    const [, ts, v1] = signatureMatch;
    
    // Construir el manifest seg√∫n documentaci√≥n oficial
    const manifest = buildSignatureManifest({ ts, id, requestId });
    
    // Calcular firma esperada
    const expectedSignature = crypto
      .createHmac('sha256', secret)
      .update(manifest)
      .digest('hex');
    
    // Comparaci√≥n segura
    const isValid = crypto.timingSafeEqual(
      Buffer.from(expectedSignature, 'hex'),
      Buffer.from(v1, 'hex')
    );
    
    logInfo('üîç Validaci√≥n de firma webhook:', {
      manifest,
      ts,
      id,
      requestId,
      signatureValid: isValid,
      expectedStart: expectedSignature.substring(0, 10) + '...',
      receivedStart: v1.substring(0, 10) + '...'
    });
    
    return isValid;
    
  } catch (error) {
    logError('‚ùå Error en verificaci√≥n de firma:', error);
    return false;
  }
}

export async function POST(req) {
  const startTime = Date.now();
  logInfo('üîî Webhook: Iniciando procesamiento');

  try {
    // 1. Extraer query parameters
    const url = new URL(req.url);
    const queryParams = {};
    for (const [key, value] of url.searchParams.entries()) {
      queryParams[key] = value;
    }
    
    // 2. Obtener datos necesarios para validaci√≥n
    const id = queryParams['data.id'];
    const requestId = req.headers.get('x-request-id') || req.headers.get('X-Request-Id') || '';
    const signatureHeader = req.headers.get('x-signature') || '';
    const secret = process.env.MERCADOPAGO_WEBHOOK_KEY;
    
    // 3. Obtener body
    const rawBody = await req.text();
    
    if (!rawBody) {
      logError('‚ùå Webhook: Cuerpo vac√≠o recibido');
      return NextResponse.json({ error: 'Empty body' }, { status: 400 });
    }

    // Log detallado para debugging
    logInfo('üìã Datos del webhook recibidos:', {
      id,
      requestId,
      hasSignature: !!signatureHeader,
      bodyLength: rawBody.length,
      queryParams,
      userAgent: req.headers.get('user-agent')
    });

    // 4. Validar firma (obligatorio en producci√≥n)
    if (process.env.NODE_ENV === 'production') {
      if (!signatureHeader || !id || !secret) {
        logError('‚ùå Webhook: Datos requeridos faltantes para validaci√≥n', {
          hasSignature: !!signatureHeader,
          hasId: !!id,
          hasSecret: !!secret,
          hasRequestId: !!requestId
        });
        return NextResponse.json({ error: 'Missing required data for validation' }, { status: 400 });
      }

      const isValid = verifyWebhookSignature({
        signatureHeader,
        rawBody,
        secret,
        id,
        requestId
      });

      if (!isValid) {
        logError('‚ùå Webhook: Firma inv√°lida en producci√≥n');
        return NextResponse.json({ error: 'Invalid signature' }, { status: 401 });
      }
      
      logInfo('‚úÖ Webhook: Firma v√°lida');
    } else {
      logInfo('üîß Webhook: Modo desarrollo - validaci√≥n de firma omitida');
    }

    // 5. Parsear notificaci√≥n
    let notification;
    try {
      notification = JSON.parse(rawBody);
      logInfo('üìã Notificaci√≥n parseada:', {
        action: notification.action,
        type: notification.type,
        dataId: notification.data?.id,
        liveMode: notification.live_mode
      });
    } catch (parseError) {
      logError('‚ùå Webhook: Error parseando JSON:', parseError);
      return NextResponse.json({ error: 'Invalid JSON' }, { status: 400 });
    }

    // 6. Obtener payment ID de m√∫ltiples fuentes
    const paymentId = notification.data?.id || id;
    const eventType = notification.type || notification.action;
    
    if (!paymentId) {
      logWarn('‚ö†Ô∏è Webhook: Notificaci√≥n sin payment ID');
      return NextResponse.json({ received: true }, { status: 200 });
    }
    
    logInfo(`üîî Webhook v√°lido: tipo=${eventType}, payment_id=${paymentId}`);

    // 7. Procesar solo notificaciones de pago
    if (eventType === 'payment' || eventType === 'payment.updated' || eventType === 'payment.created') {
      await handlePaymentNotification(paymentId);
    } else {
      logInfo(`‚ÑπÔ∏è Webhook: Tipo de evento no procesado: ${eventType}`);
    }

    const processingTime = Date.now() - startTime;
    logInfo(`‚úÖ Webhook procesado exitosamente en ${processingTime}ms`);
    
    return NextResponse.json({ received: true }, { status: 200 });

  } catch (error) {
    const processingTime = Date.now() - startTime;
    logError(`‚ùå Webhook: Error general tras ${processingTime}ms:`, {
      message: error.message,
      stack: error.stack
    });
    
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

// Funci√≥n principal para manejar notificaciones de pago
// ‚úÖ MODIFICACI√ìN: Webhook como autoridad principal
async function handlePaymentNotification(paymentId) {
  try {
    logInfo(`üîç Procesando pago: ${paymentId}`);

    // 1. Obtener informaci√≥n del pago desde MercadoPago
    const mpClient = new MercadoPagoConfig({ 
      accessToken: process.env.MERCADOPAGO_ACCESS_TOKEN 
    });
    const paymentClient = new Payment(mpClient);
    
    let paymentInfo;
    try {
      const paymentResponse = await paymentClient.get({ id: paymentId });
      paymentInfo = paymentResponse;
      
      if (!paymentInfo || typeof paymentInfo !== 'object') {
        logError(`‚ùå Respuesta inv√°lida de MercadoPago para pago ${paymentId}:`, paymentResponse);
        return;
      }
      
    } catch (apiError) {
      logError(`‚ùå Error consultando API de MercadoPago para pago ${paymentId}:`, {
        message: apiError.message,
        cause: apiError.cause,
        status: apiError.status
      });
      return;
    }
    
    const currentStatus = paymentInfo.status;
    const statusDetail = paymentInfo.status_detail;
    const externalReference = paymentInfo.external_reference;

    logInfo(`üí∞ Pago ${paymentId}: status=${currentStatus}, detail=${statusDetail}, ref=${externalReference}`);

    if (!externalReference) {
      logWarn(`‚ö†Ô∏è Pago ${paymentId} sin external_reference - ignorando`);
      return;
    }

    // 2. ‚úÖ USAR: Nueva l√≥gica de retry inteligente
    const { paymentRequest, error: fetchError } = await findPaymentRequestWithRetry(
      externalReference, 
      currentStatus
    );

    if (fetchError || !paymentRequest) {
      if (WEBHOOK_RETRY_CONFIG.RETRY_STATES.includes(currentStatus)) {
        // Ejecutar diagn√≥stico antes de reportar error
        await diagnoseTimingIssue(externalReference, paymentId);
        
        logError(`‚ùå CR√çTICO: Payment request ${externalReference} no encontrado para pago ${currentStatus}`);
        logError(`üîç Esto puede indicar problema de sincronizaci√≥n o datos perdidos`);
        
        // ‚úÖ OPCIONAL: Notificar a administradores de problema cr√≠tico
        await notifyAdminsOfMissingPaymentRequest(paymentId, externalReference, currentStatus);
      } else {
        logInfo(`‚ÑπÔ∏è Payment request ${externalReference} no encontrado para pago ${currentStatus} - esperado`);
      }
      return;
    }

    const previousStatus = paymentRequest.payment_status;
    logInfo(`üìä Estado: ${previousStatus} ‚Üí ${currentStatus}`);

    // 3. Verificar si necesita actualizaci√≥n
    const needsUpdate = shouldUpdatePaymentStatus(previousStatus, currentStatus);
    
    if (!needsUpdate) {
      logInfo(`‚úÖ Pago ${paymentId} no necesita actualizaci√≥n: ${previousStatus} ‚Üí ${currentStatus}`);
      return;
    }

    // 4. Actualizar estado en payment_requests
    const { error: updateError } = await supabase
      .from('payment_requests')
      .update({
        payment_status: currentStatus,
        payment_detail: statusDetail,
        payment_id: paymentId,
        updated_at: new Date().toISOString()
      })
      .eq('id', externalReference);

    if (updateError) {
      logError(`‚ùå Error actualizando payment_request ${externalReference}:`, updateError);
      return;
    }

    logInfo(`‚úÖ Payment request ${externalReference} actualizado exitosamente`);

    // 5. Ejecutar acciones seg√∫n transici√≥n de estado
    await handleStatusTransition(previousStatus, currentStatus, paymentRequest, paymentInfo);

  } catch (error) {
    logError(`‚ùå Error procesando pago ${paymentId}:`, {
      message: error.message,
      stack: error.stack
    });
  }
}

// ‚úÖ NUEVA CONFIGURACI√ìN: Par√°metros de retry configurables
const WEBHOOK_RETRY_CONFIG = {
  // Estados que justifican retry (pagos que deber√≠an tener payment_request)
  RETRY_STATES: ['approved', 'pending', 'in_process'],
  // Estados que no justifican retry (pagos que pueden no tener payment_request)
  NO_RETRY_STATES: ['rejected', 'cancelled'],
  // Configuraci√≥n de reintentos
  MAX_RETRIES: 3,
  INITIAL_DELAY: 1000, // 1 segundo
  MAX_DELAY: 5000,     // 5 segundos m√°ximo
  BACKOFF_MULTIPLIER: 1.5
};

// ‚úÖ MEJORAR: Funci√≥n de retry con configuraci√≥n avanzada
async function findPaymentRequestWithRetry(externalReference, paymentStatus) {
  const config = WEBHOOK_RETRY_CONFIG;
  
  // Decidir si usar retry basado en el estado del pago
  if (!config.RETRY_STATES.includes(paymentStatus)) {
    logInfo(`üö´ Estado ${paymentStatus} no requiere retry - b√∫squeda simple`);
    const { data, error } = await supabase
      .from('payment_requests')
      .select('*')
      .eq('id', externalReference)
      .single();
    return { paymentRequest: data, error };
  }

  // Usar retry logic para estados que lo justifican
  let currentDelay = config.INITIAL_DELAY;
  
  for (let attempt = 1; attempt <= config.MAX_RETRIES; attempt++) {
    const startTime = Date.now();
    logInfo(`üîÑ [${attempt}/${config.MAX_RETRIES}] Buscando payment_request: ${externalReference}`);
    
    const { data: paymentRequest, error: fetchError } = await supabase
      .from('payment_requests')
      .select('*')
      .eq('id', externalReference)
      .single();

    if (!fetchError && paymentRequest) {
      const searchTime = Date.now() - startTime;
      logInfo(`‚úÖ Payment request encontrado en intento ${attempt} (${searchTime}ms): ${externalReference}`);
      return { paymentRequest, error: null };
    }

    if (attempt < config.MAX_RETRIES) {
      logInfo(`‚è≥ Intento ${attempt} fallido, esperando ${currentDelay}ms...`);
      await new Promise(resolve => setTimeout(resolve, currentDelay));
      
      // Backoff exponencial con l√≠mite
      currentDelay = Math.min(currentDelay * config.BACKOFF_MULTIPLIER, config.MAX_DELAY);
    } else {
      logError(`‚ùå Payment request ${externalReference} no encontrado despu√©s de ${config.MAX_RETRIES} intentos`);
    }
  }

  return { paymentRequest: null, error: fetchError };
}

// ‚úÖ NUEVA: Funci√≥n para notificar problemas cr√≠ticos
async function notifyAdminsOfMissingPaymentRequest(paymentId, externalReference, paymentStatus) {
  try {
    logError(`üö® PROBLEMA CR√çTICO: Payment request perdido`, {
      paymentId,
      externalReference,
      paymentStatus,
      timestamp: new Date().toISOString(),
      severity: 'CRITICAL'
    });
    
    // Aqu√≠ podr√≠as enviar email, Slack, etc.
    // await sendAdminAlert({...});
    
  } catch (error) {
    logError(`‚ùå Error notificando problema cr√≠tico:`, error);
  }
}

// ‚úÖ NUEVA FUNCI√ìN: Determinar si necesita actualizaci√≥n
function shouldUpdatePaymentStatus(previousStatus, currentStatus) {
  // No actualizar si es el mismo estado
  if (previousStatus === currentStatus) {
    return false;
  }

  // Matriz de transiciones v√°lidas
  const validTransitions = {
    'pending': ['approved', 'rejected', 'cancelled', 'in_process'],
    'in_process': ['approved', 'rejected', 'cancelled'],
    'approved': ['refunded', 'charged_back'], // Solo para reembolsos y contracargos
    'rejected': [], // Los rechazados no cambian
    'cancelled': [], // Los cancelados no cambian
    'refunded': ['charged_back'], // Reembolsado puede tener contracargo
    'charged_back': [] // Contracargo es final
  };

  const allowedNext = validTransitions[previousStatus] || [];
  return allowedNext.includes(currentStatus);
}

// ‚úÖ NUEVA FUNCI√ìN: Manejar transiciones de estado
async function handleStatusTransition(previousStatus, currentStatus, paymentRequest, paymentInfo) {
  const paymentId = paymentInfo.id;
  
  logInfo(`üîÑ Procesando transici√≥n: ${previousStatus} ‚Üí ${currentStatus} para pago ${paymentId}`);

  switch (currentStatus) {
    case 'approved':
      if (previousStatus !== 'approved') {
        await handlePaymentApproved(paymentRequest, paymentInfo);
      }
      break;
      
    case 'rejected':
      if (previousStatus !== 'rejected') {
        await handlePaymentRejected(paymentRequest, paymentInfo);
      }
      break;
      
    case 'refunded':
      await handlePaymentRefunded(paymentRequest, paymentInfo);
      break;
      
    case 'charged_back':
      await handlePaymentChargedBack(paymentRequest, paymentInfo);
      break;
      
    case 'cancelled':
      await handlePaymentCancelled(paymentRequest, paymentInfo);
      break;
      
    default:
      logInfo(`‚ÑπÔ∏è Estado ${currentStatus} no requiere acciones especiales`);
  }
}

// ‚úÖ RENOMBRAR Y MEJORAR: Funciones espec√≠ficas por estado
async function handlePaymentApproved(paymentRequest, paymentInfo) {
  const paymentId = paymentInfo.id;
  
  try {
    logInfo(`üéâ Procesando pago aprobado: ${paymentId}`);

    // 1. Actualizar stock (solo si no se hizo antes)
    let orderItems = paymentRequest.order_items;
    if (typeof orderItems === 'string') {
      orderItems = JSON.parse(orderItems);
    }

    if (Array.isArray(orderItems) && orderItems.length > 0) {
      await updateStockAfterOrder(orderItems);
      logInfo(`üì¶ Stock actualizado para pago ${paymentId}`);
    }

    // 2. Crear orden definitiva
    await createFinalOrder(paymentRequest, paymentInfo);

    // 3. ‚úÖ NUEVO: Enviar email de APROBACI√ìN (no de confirmaci√≥n)
    await sendPaymentApprovedEmail(paymentRequest, paymentInfo);

    logInfo(`‚úÖ Pago ${paymentId} aprobado procesado completamente`);

  } catch (error) {
    logError(`‚ùå Error procesando pago aprobado ${paymentId}:`, error);
  }
}

async function handlePaymentRejected(paymentRequest, paymentInfo) {
  const paymentId = paymentInfo.id;
  logInfo(`‚ùå Pago ${paymentId} rechazado - no se requieren acciones adicionales`);
  
  // ‚úÖ OPCIONAL: Enviar email de rechazo si se desea
  // await sendPaymentRejectedEmail(paymentRequest, paymentInfo);
}

async function handlePaymentRefunded(paymentRequest, paymentInfo) {
  const paymentId = paymentInfo.id;
  
  try {
    logInfo(`üí∞ Procesando reembolso para pago: ${paymentId}`);

    // 1. Restaurar stock
    let orderItems = paymentRequest.order_items;
    if (typeof orderItems === 'string') {
      orderItems = JSON.parse(orderItems);
    }

    if (Array.isArray(orderItems) && orderItems.length > 0) {
      await restoreStockAfterRefund(orderItems);
      logInfo(`üì¶ Stock restaurado para reembolso ${paymentId}`);
    }

    // 2. Marcar orden como reembolsada
    await updateOrderStatus(paymentRequest.id, 'refunded');

    // 3. Enviar email de reembolso
    await sendRefundEmail(paymentRequest, paymentInfo);

  } catch (error) {
    logError(`‚ùå Error procesando reembolso ${paymentId}:`, error);
  }
}

async function handlePaymentChargedBack(paymentRequest, paymentInfo) {
  const paymentId = paymentInfo.id;
  
  try {
    logInfo(`‚ö†Ô∏è Procesando contracargo para pago: ${paymentId}`);

    // 1. Restaurar stock
    let orderItems = paymentRequest.order_items;
    if (typeof orderItems === 'string') {
      orderItems = JSON.parse(orderItems);
    }

    if (Array.isArray(orderItems) && orderItems.length > 0) {
      await restoreStockAfterRefund(orderItems);
      logInfo(`üì¶ Stock restaurado por contracargo ${paymentId}`);
    }

    // 2. Marcar orden como contracargo
    await updateOrderStatus(paymentRequest.id, 'charged_back');

    // 3. ‚úÖ IMPORTANTE: Notificar a administradores
    await notifyChargebackToAdmins(paymentRequest, paymentInfo);

  } catch (error) {
    logError(`‚ùå Error procesando contracargo ${paymentId}:`, error);
  }
}

async function handlePaymentCancelled(paymentRequest, paymentInfo) {
  const paymentId = paymentInfo.id;
  logInfo(`üö´ Pago ${paymentId} cancelado - marcando como cancelado`);
  
  // Solo actualizar estado, no se requieren m√°s acciones
}

// Crear orden definitiva
async function createFinalOrder(paymentRequest, paymentInfo) {
  try {
    const orderData = {
      id: `ORDER_${paymentRequest.id}`,
      payment_id: paymentInfo.id,
      payment_request_id: paymentRequest.id,
      customer_data: paymentRequest.customer_data,
      order_items: paymentRequest.order_items,
      total_amount: paymentRequest.total_amount,
      payment_status: 'approved',
      payment_detail: paymentInfo.status_detail,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    const { error } = await supabase
      .from('orders')
      .insert([orderData]);

    if (error) {
      logError(`‚ùå Error creando orden definitiva:`, error);
    } else {
      logInfo(`‚úÖ Orden definitiva creada: ORDER_${paymentRequest.id}`);
    }

  } catch (error) {
    logError(`‚ùå Error en createFinalOrder:`, error);
  }
}

// Enviar email de confirmaci√≥n
async function sendConfirmationEmail(paymentRequest, paymentInfo) {
  try {
    const customerData = paymentRequest.customer_data;
    let orderItems = paymentRequest.order_items;

    if (typeof orderItems === 'string') {
      orderItems = JSON.parse(orderItems);
    }

    if (!customerData?.email) {
      logWarn(`‚ö†Ô∏è No hay email para enviar confirmaci√≥n del pago ${paymentInfo.id}`);
      return;
    }

    // Generar PDF
    const receiptPDF = await generateReceiptPDF({
      orderId: paymentRequest.id,
      customerData,
      items: orderItems,
      totalAmount: paymentRequest.total_amount,
      paymentStatus: 'approved',
      paymentId: paymentInfo.id
    });

    // Enviar email
    const emailResult = await sendReceiptEmail({
      to: customerData.email,
      customerName: `${customerData.first_name || ''} ${customerData.last_name || ''}`.trim(),
      orderId: paymentRequest.id,
      paymentId: paymentInfo.id,
      amount: paymentRequest.total_amount,
      items: orderItems,
      pdfAttachment: receiptPDF
    });

    if (emailResult.success) {
      logInfo(`‚úÖ Email enviado a ${customerData.email}`);
    } else {
      logError(`‚ùå Error enviando email:`, emailResult.error);
    }

  } catch (error) {
    logError(`‚ùå Error en sendConfirmationEmail:`, error);
  }
}

// ‚úÖ NUEVO: Enviar email de aprobaci√≥n de pago
async function sendPaymentApprovedEmail(paymentRequest, paymentInfo) {
  try {
    const customerData = paymentRequest.customer_data;
    let orderItems = paymentRequest.order_items;

    if (typeof orderItems === 'string') {
      orderItems = JSON.parse(orderItems);
    }

    if (!customerData?.email) {
      logWarn(`‚ö†Ô∏è No hay email para enviar confirmaci√≥n del pago ${paymentInfo.id}`);
      return;
    }

    // Generar PDF
    const receiptPDF = await generateReceiptPDF({
      orderId: paymentRequest.id,
      customerData,
      items: orderItems,
      totalAmount: paymentRequest.total_amount,
      paymentStatus: 'approved',
      paymentId: paymentInfo.id
    });

    // Enviar email usando funci√≥n existente
    const emailResult = await sendReceiptEmail({
      to: customerData.email,
      customerName: `${customerData.first_name || ''} ${customerData.last_name || ''}`.trim(),
      orderId: paymentRequest.id,
      paymentId: paymentInfo.id,
      amount: paymentRequest.total_amount,
      items: orderItems,
      pdfAttachment: receiptPDF
    });

    if (emailResult.success) {
      logInfo(`‚úÖ Email de aprobaci√≥n enviado a ${customerData.email}`);
    } else {
      logError(`‚ùå Error enviando email:`, emailResult.error);
    }

  } catch (error) {
    logError(`‚ùå Error en sendPaymentApprovedEmail:`, error);
  }
}

// ‚úÖ ELIMINAR: Funciones duplicadas que ya existen en emailService.js
// - sendRefundEmail (ya existe)
// - notifyChargebackToAdmins (ya existe)

// ‚úÖ NUEVA: Funci√≥n de diagn√≥stico de timing
async function diagnoseTimingIssue(externalReference, paymentId) {
  try {
    logInfo(`üî¨ Diagn√≥stico de timing para: ${externalReference}`);
    
    // Buscar registros relacionados con diferentes timestamps
    const { data: allRecords, error } = await supabase
      .from('payment_requests')
      .select('id, created_at, payment_id, payment_status')
      .or(`id.eq.${externalReference},payment_id.eq.${paymentId}`)
      .order('created_at', { ascending: false })
      .limit(5);
    
    if (!error && allRecords) {
      logInfo(`üîç Registros relacionados encontrados:`, {
        count: allRecords.length,
        records: allRecords.map(r => ({
          id: r.id,
          payment_id: r.payment_id,
          created_at: r.created_at,
          status: r.payment_status
        }))
      });
    }
    
    // Buscar registros creados recientemente (√∫ltimos 30 segundos)
    const thirtySecondsAgo = new Date(Date.now() - 30000).toISOString();
    const { data: recentRecords } = await supabase
      .from('payment_requests')
      .select('id, created_at, payment_id')
      .gte('created_at', thirtySecondsAgo)
      .order('created_at', { ascending: false });
    
    if (recentRecords && recentRecords.length > 0) {
      logInfo(`üìä Payment requests creados en √∫ltimos 30s:`, {
        count: recentRecords.length,
        records: recentRecords.slice(0, 3) // Solo los primeros 3
      });
    }
    
  } catch (error) {
    logError(`‚ùå Error en diagn√≥stico de timing:`, error);
  }
}